## How C++ Works
	.cpp -> .obj -> .exe(linker)
`#` 符号后都是预处理语句，他们都会在编译之前执行，如如下代码中的 `include` 语句，它会寻找一个叫 `iostream` 的文件，找到后会将 `iostream` 文件内的所有内容完整地**拷贝**到当前文件中。此外，这种文件又被称为**头文件** (head file)。
***
## How the C++ Complier Works
在 C++ 中任何符号都需要声明，我们对每个文件都会单独编译，如果调用一个外部函数，却不在当前文件进行声明，那么当前文件就不知道还有这样的一个函数存在。如果你声明了却没有定义函数，编译器依旧完全相信你，但链接器试图寻找你定义的函数时却找不到该函数就会报链接错误。如果都正确了，编译器会将每个文件但单独编译为 .obj 文件，而链接器会将他们合并为一个可执行文件，例如 `.exe` 文件。

编译器将文本转换成一种称为目标文件的中间格式，在这个过程中，编译器会先预处理代码，将我们的代码转为抽象的语法树，然后生成 CPU 所执行的代码.
***
## How the C++ Linker Works 
C++ 程序必须有一个入口函数，如 `main` 函数，你也可以在 IDE 中修改这个函数名。但链接器总会寻找你所指定的入口函数，如果没有定义它，就会报链接器错误。

由于编译器是相信你的，但假如你在文件中声明了函数，却没有真正地定义，此时只有链接器才会找到这个错误。即使你并没有调用这个未定义地函数，链接器依旧会报错，因为链接器不能确定别的文件就不会调用。但如果用 `static` 关键字修饰函数，那么该函数就只在当前文件生效，也就是说链接器就不会认为由外部文件调用该函数。
### 链接错误
如果在同一的文件存在相同的定义，那么编译器就会检查到该错误，但如果是不同的文件存在相同的定义，只能由链接器检查到该错误。当使用 `#include` 语句时可能会导致头文件多次被拷贝在不同文件中，也就会触发这种链接错误。我们可以通过将声明都放在一个头文件中，不同的翻译单元分别包含头文件，避免定义被拷贝。
***


  